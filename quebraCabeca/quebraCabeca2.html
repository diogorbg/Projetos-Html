<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quebra-Cabeça com SVG Clip-Path e Escala</title>
  <style>
    /* ------------------ */
    /* CSS EMBUTIDO */
    /* ------------------ */
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: #f4f4f4;
    }

    .controls {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: #fff;
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    .piece {
      box-sizing: border-box;
      cursor: pointer;
      position: relative;
      background-size: 400px 400px;
      /* Será ajustado pelo JS */

      border: 2px solid rgba(0, 0, 0, 0);
      clip-path: url(#puzzle-clip);
      /* Importante: Define o ponto de origem da transformação para o centro da peça */
      transform-origin: center center;
      transform: scale(1);
      /* Estado padrão (correta) */
    }

    /* 1. NOVA CLASSE PARA ESCALA NAS PEÇAS ERRADAS */
    .piece.wrong-position {
      transform: scale(0.85);
      /* Z-index é útil para evitar que a peça reduzida "corte" o clip-path da peça vizinha. */
      z-index: 0;
      /* Adiciona uma sombra suave para dar mais profundidade */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    #svg-clip-container {
      position: absolute;
      width: 0;
      height: 0;
    }

    #puzzle-container {
      width: 400px;
      height: 400px;
      border: 5px solid #333;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      display: grid;
      gap: 0;
      background-color: #333;
      /* Fundo escuro para contrastar com peças menores */
      border-radius: 5px;
      /* overflow: hidden; foi removido, pois peças fora de escala podem precisar de espaço */
    }

    .piece.selected {
      border: 2px solid gold;
      box-shadow: 0 0 15px rgba(255, 215, 0, 1);
      z-index: 10;
      /* Sempre no topo */
      _transform: scale(1);
      /* Levemente maior ao selecionar */
    }

    #message {
      margin-top: 15px;
      font-weight: bold;
      color: green;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }
  </style>
</head>

<body>

  <div id="svg-clip-container">
    <svg width="0" height="0" viewBox="0 0 100 100">
      <defs>
        <path id="straight-side" d="M0 0 L100 0 L100 100 L0 100 Z" />
        <path id="tab-out" d="M0 0 L35 0 C35 10, 65 10, 65 0 L100 0 L100 100 L0 100 Z" />
        <path id="tab-in" d="M0 0 L35 0 C35 -10, 65 -10, 65 0 L100 0 L100 100 L0 100 Z" />
      </defs>
    </svg>
  </div>

  <h1>Quebra-Cabeça com SVG Clip-Path e Escala</h1>

  <div class="controls">
    <div class="control-group">
      <label for="image-upload">1. Selecione a Imagem:</label>
      <input type="file" id="image-upload" accept="image/*">
    </div>

    <div class="control-group">
      <label for="parts-count">2. Partes por Lado (Ex: 3 para 3x3):</label>
      <input type="number" id="parts-count" value="3" min="2" max="6" style="width: 50px;">
    </div>

    <button id="start-button" disabled>3. Iniciar Quebra-Cabeça</button>
  </div>

  <div id="puzzle-container">
    <p style="padding: 20px; text-align: center; color: #666;">Carregue uma imagem e clique em Iniciar.</p>
  </div>

  <div id="message"></div>

  <script>
    // ------------------
    // JAVASCRIPT EMBUTIDO
    // ------------------
    const imageUpload = document.getElementById('image-upload');
    const partsCountInput = document.getElementById('parts-count');
    const startButton = document.getElementById('start-button');
    const puzzleContainer = document.getElementById('puzzle-container');
    const messageDiv = document.getElementById('message');
    const svgContainer = document.getElementById('svg-clip-container');

    let originalImage = null;
    let pieces = [];
    let board = [];
    let selectedPieceIndex = -1;
    let partsPerSide = 3;
    const CONTAINER_SIZE = 400;
    const TAB_SIZE_RATIO = 0.1;

    // -----------------------------------------------------------
    // 1. FUNÇÕES DO JOGO
    // -----------------------------------------------------------

    imageUpload.addEventListener('change', function (event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            originalImage = img;
            startButton.disabled = false;
            messageDiv.textContent = "Imagem carregada. Clique em Iniciar.";
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    startButton.addEventListener('click', startGame);

    function startGame() {
      if (!originalImage) return;

      partsPerSide = parseInt(partsCountInput.value);
      if (partsPerSide < 2 || partsPerSide > 6 || isNaN(partsPerSide)) {
        alert("O número de partes por lado deve estar entre 2 e 6.");
        return;
      }

      messageDiv.textContent = "Jogo iniciado! Monte o quebra-cabeça.";

      createPieces();
      shuffleBoard();
      drawBoard();
    }

    function createPieces() {
      pieces = [];
      board = [];

      const pieceSize = CONTAINER_SIZE / partsPerSide;

      // Limpar o contêiner
      puzzleContainer.innerHTML = '';
      puzzleContainer.style.gridTemplateColumns = `repeat(${partsPerSide}, 1fr)`;
      puzzleContainer.style.gridTemplateRows = `repeat(${partsPerSide}, 1fr)`;
      puzzleContainer.style.width = `${CONTAINER_SIZE}px`;
      puzzleContainer.style.height = `${CONTAINER_SIZE}px`;


      // 1. Criar o array de conexões
      const connectionsMap = [];
      for (let i = 0; i < partsPerSide * partsPerSide; i++) {
        const row = Math.floor(i / partsPerSide);
        const col = i % partsPerSide;

        const connections = {
          top: row === 0 ? 0 : (Math.random() < 0.5 ? 1 : -1),
          right: col === partsPerSide - 1 ? 0 : (Math.random() < 0.5 ? 1 : -1),
          bottom: 0,
          left: 0
        };
        connectionsMap.push(connections);
      }

      // 2. Corrigir as conexões para garantir que se encaixem
      for (let i = 0; i < partsPerSide * partsPerSide; i++) {
        const row = Math.floor(i / partsPerSide);
        const col = i % partsPerSide;
        const connections = connectionsMap[i];

        if (row < partsPerSide - 1) {
          // O bottom da peça atual é o oposto do top da peça abaixo
          connections.bottom = -connectionsMap[i + partsPerSide].top;
        }
        if (col > 0) {
          // O left da peça atual é o oposto do right da peça à esquerda
          connections.left = -connectionsMap[i - 1].right;
        }
      }

      // 3. Criar os elementos HTML
      for (let i = 0; i < partsPerSide * partsPerSide; i++) {
        const connections = connectionsMap[i];
        const row = Math.floor(i / partsPerSide);
        const col = i % partsPerSide;

        const pieceElement = document.createElement('div');
        pieceElement.classList.add('piece');
        pieceElement.dataset.correctId = i; // ID correto (0, 1, 2...)
        pieceElement.connections = connections;

        pieceElement.style.width = `${pieceSize}px`;
        pieceElement.style.height = `${pieceSize}px`;

        // Configurar o fundo para mostrar a parte correta da imagem
        const backgroundX = -col * pieceSize;
        const backgroundY = -row * pieceSize;

        pieceElement.style.backgroundImage = `url(${originalImage.src})`;
        pieceElement.style.backgroundSize = `${CONTAINER_SIZE}px ${CONTAINER_SIZE}px`;
        pieceElement.style.backgroundPosition = `${backgroundX}px ${backgroundY}px`;

        // 4. Aplicar o clip-path dinâmico
        const svgPathD = createPuzzlePathD(connections, pieceSize);
        pieceElement.style.clipPath = `path('${svgPathD}')`;

        pieces.push(pieceElement);
        board.push(i);
      }
    }

    // Função de Path D (inalterada)
    function createPuzzlePathD(connections, size) {
      const S = size; // Tamanho
      const T = S * TAB_SIZE_RATIO; // Tamanho da Aba (10% do tamanho)
      const p1 = S / 3; // 1/3
      const p2 = (S * 2) / 3; // 2/3

      let d = `M 0 0`; // Começa no canto superior esquerdo (0,0)

      // Borda Superior (Lado 0 -> S, Y=0)
      d += ` L ${p1} 0`;
      d += createTab(p1, 0, p2, 0, T * connections.top, 'horizontal');
      d += ` L ${S} 0`;

      // Borda Direita (Lado S, Y=0 -> S)
      d += ` L ${S} ${p1}`;
      d += createTab(S, p1, S, p2, T * connections.right, 'vertical');
      d += ` L ${S} ${S}`;

      // Borda Inferior (Lado S -> 0, Y=S). Invertida!
      d += ` L ${p2} ${S}`;
      d += createTab(p2, S, p1, S, T * connections.bottom, 'horizontal', true);
      d += ` L 0 ${S}`;

      // Borda Esquerda (Lado 0, Y=S -> 0). Invertida!
      d += ` L 0 ${p2}`;
      d += createTab(0, p2, 0, p1, T * connections.left, 'vertical', true);
      d += ` L 0 0 Z`;

      return d;
    }

    // Função de Tab (inalterada)
    function createTab(x1, y1, x2, y2, tabSize, orientation, reverse = false) {
      const C = tabSize * 0.4; // Ponto de controle
      let segment = '';

      if (orientation === 'horizontal') {
        if (!reverse) {
          segment = `C ${x1 + C} ${y1 + tabSize}, ${x2 - C} ${y2 + tabSize}, ${x2} ${y2}`;
        } else { // Invertido
          segment = `C ${x1 - C} ${y1 + tabSize}, ${x2 + C} ${y2 + tabSize}, ${x2} ${y2}`;
        }
      } else { // Vertical
        if (!reverse) {
          segment = `C ${x1 + tabSize} ${y1 + C}, ${x2 + tabSize} ${y2 - C}, ${x2} ${y2}`;
        } else { // Invertido
          segment = `C ${x1 + tabSize} ${y1 - C}, ${x2 + tabSize} ${y2 + C}, ${x2} ${y2}`;
        }
      }
      return segment;
    }


    function shuffleBoard() {
      // Embaralhamento de Fisher-Yates
      for (let i = board.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [board[i], board[j]] = [board[j], board[i]];
      }
    }

    // 2. FUNÇÃO DRAWBOARD MODIFICADA PARA TRATAR ESCALA
    function drawBoard() {
      puzzleContainer.innerHTML = '';
      board.forEach((pieceId, index) => {
        const pieceElement = pieces[pieceId];
        pieceElement.classList.remove('selected');

        // Verifica se a peça está na posição correta
        const isCorrect = pieceId === index;

        // Aplica ou remove a classe de escala
        if (!isCorrect) {
          pieceElement.classList.add('wrong-position');
        } else {
          pieceElement.classList.remove('wrong-position');
        }

        // Reseta transform para o padrão da classe base, para que o 'selected' funcione
        pieceElement.style.transform = '';

        pieceElement.onclick = () => selectPiece(index);
        puzzleContainer.appendChild(pieceElement);
      });
      selectedPieceIndex = -1;
    }

    function selectPiece(clickedIndex) {
      const pieceElement = puzzleContainer.children[clickedIndex];

      if (selectedPieceIndex === -1) {
        // Seleciona a primeira peça
        selectedPieceIndex = clickedIndex;
        pieceElement.classList.add('selected');
      } else if (selectedPieceIndex === clickedIndex) {
        // Desseleciona a peça
        selectedPieceIndex = -1;
        pieceElement.classList.remove('selected');
      } else {
        // Troca as posições no array 'board'
        const firstPieceId = board[selectedPieceIndex];
        const secondPieceId = board[clickedIndex];

        board[selectedPieceIndex] = secondPieceId;
        board[clickedIndex] = firstPieceId;

        // Redesenha para aplicar a nova escala e remover a seleção
        drawBoard();
        checkWin();
      }
    }

    function checkWin() {
      const isSolved = board.every((pieceId, index) => pieceId === index);

      if (isSolved) {
        messageDiv.textContent = "PARABÉNS! Quebra-Cabeça Resolvido!";
        // Assegura que todas as peças fiquem com scale(1)
        Array.from(puzzleContainer.children).forEach(piece => {
          piece.onclick = null;
          piece.classList.remove('wrong-position');
        });
        startButton.disabled = false;
      }
    }

  </script>

</body>

</html>